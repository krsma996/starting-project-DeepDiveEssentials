/*
  U React-u postoji viÅ¡e naÄina da prosledimo funkcije kroz props 
  â€“ posebno kada Å¾elimo da prosledimo i argumente.

  Jedan od uobiÄajenih naÄina je koriÅ¡Ä‡enje **arrow funkcije unutar JSX-a**.

  // Primer:
  function onClick(selectedTab) {
    console.log(selectedTab);
  }

  function App() {
    return (
      <>
        <TabButton onClick={() => onClick("Components")}>Components</TabButton>
        <TabButton onClick={() => onClick("JSX")}>JSX</TabButton>
        <TabButton onClick={() => onClick("State")}>State</TabButton>
        <TabButton onClick={() => onClick("Props")}>Props</TabButton>
      </>
    );
  }

  // Komponenta TabButton:
  export default function TabButton({ children, onClick }) {
    return (
      <li>
        <button onClick={onClick}>{children}</button>
      </li>
    );
  }

  // ObjaÅ¡njenje:
  // Kada koristimo <TabButton onClick={() => onClick("Components")}>...</TabButton>,
  // zapravo prosleÄ‘ujemo funkciju (callback) koju React ne izvrÅ¡ava odmah prilikom renderovanja.
  // Ta funkcija se poziva *tek kada korisnik klikne dugme*.
  // To omoguÄ‡ava da prosledimo i dodatne argumente (npr. "Components") u funkciju `onClick`.
  // Da nismo koristili arrow funkciju, `onClick("Components")` bi se odmah izvrÅ¡io prilikom uÄitavanja komponente,
  // Å¡to nije poÅ¾eljno u ovom sluÄaju.


  Dakle ovde se radi o callback funkciji a to je 
  ğŸ‘‰ Callback funkcija u JavaScriptu je funkcija koja se prosleÄ‘uje drugoj funkciji kao argument i poziva se kasnije.
  
  Primer

  function pozdrav(ime) {
  console.log("Zdravo, " + ime);
}

function obradiKorisnika(callback) {
  const ime = "Marko";
  callback(ime); // pozivamo prosleÄ‘enu funkciju
}

obradiKorisnika(pozdrav); // â†’ Zdravo, Marko

Callback se ne izvrÅ¡ava odmah, veÄ‡ kad i kako mi to odluÄimo â€” 
Äesto se koristi za asinkrone operacije (npr. kada se zavrÅ¡i uÄitavanje podataka).

*/
